{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Reduce.Disjunction where

import Control.Monad (foldM, when)
import Cursor
import Data.Foldable (toList)
import Data.Maybe (isJust)
import qualified Data.Set as Set
import Feature
import {-# SOURCE #-} Reduce.Core (reduce)
import Reduce.Monad (
  RM,
  getTMCursor,
  inSubTM,
  modifyTMVN,
  throwFatal,
 )
import Reduce.TraceSpan (
  debugInstantOpRM,
  debugInstantRM,
  emptySpanValue,
  traceSpanArgsAdaptRM,
  traceSpanArgsRMTC,
  traceSpanRMTC,
 )
import StringIndex (ShowWTIndexer (..))
import Text.Printf (printf)
import Value
import Value.Export.Debug (treeToRepString)

reduceDisj :: Disj -> RM ()
reduceDisj d = do
  -- We have to reduce all disjuncts because they might be generated by merging one disjunction with another value.
  mapM_
    (\(i, _) -> inSubTM (mkDisjFeature i) reduce)
    (zip [0 ..] (dsjDisjuncts d))

  vc <- getTMCursor
  case valNode (focus vc) of
    VNDisj nd -> do
      newDisjT <- normalizeDisj (isJust . rtrBottom) nd vc
      modifyTMVN (valNode newDisjT)
    _ -> return ()

resolveDisjOp :: VCur -> RM (Maybe Val)
resolveDisjOp disjOpTC@(VCFocus (IsValMutable (Op (DisjOp disjOp)))) = traceSpanRMTC "resolveDisjOp" disjOpTC $ do
  let terms = toList $ djoTerms disjOp
  when (length terms < 2) $
    throwFatal $
      printf "disjunction operation requires at least 2 terms, got %d" (length terms)

  debugInstantRM "resolveDisjOp" (const $ return $ printf "terms: %s" (show terms)) disjOpTC
  disjuncts <- procMarkedTerms terms

  debugInstantRM "resolveDisjOp" (const $ return $ printf "disjuncts: %s" (show disjuncts)) disjOpTC
  if null disjuncts
    -- If none of the disjuncts are ready, return Nothing.
    then return Nothing
    else do
      let d = emptyDisj{dsjDisjuncts = disjuncts}
      r <- normalizeDisj (isJust . rtrBottom) d disjOpTC
      return $ Just r
resolveDisjOp _ = throwFatal "resolveDisjOp: focus is not a disjunction operation"

{- | Normalize a disjunction which is generated by reducing a disjunction operation.

1. Flatten the disjunction.
2. Deduplicate the disjuncts.
3. Remove the bottom disjuncts.
4. If the disjunct is left with only one element, return the value.
5. If the disjunct is left with no elements, return the first bottom it found.
-}
normalizeDisj :: (Val -> Bool) -> Disj -> VCur -> RM Val
normalizeDisj discardDisjunct d vc = do
  traceSpanArgsRMTC
    "normalizeDisj"
    ( const $ do
        dStr <- tshow (mkDisjVal d)
        return $ show dStr
    )
    vc
    $ do
      flattened <- flattenDisjunction discardDisjunct d
      final <- modifyDisjuncts discardDisjunct flattened vc
      debugInstantRM
        "normalizeDisj"
        ( const $
            return $
              printf
                "flattened: %s, flattened disjuncts: %s, final: %s"
                (show $ mkDisjVal flattened)
                (show $ dsjDisjuncts flattened)
                (show final.dsjDisjuncts)
        )
        vc
      if
        | null final.dsjDisjuncts ->
            let
              noVals = filter (\case IsNoVal -> True; _ -> False) flattened.dsjDisjuncts
              bottoms = filter (isJust . rtrBottom) flattened.dsjDisjuncts
             in
              if
                | length noVals == length flattened.dsjDisjuncts -> return $ mkNewVal VNNoVal
                | not (null bottoms) -> return $ head bottoms
                | otherwise ->
                    throwFatal $ printf "normalizeDisj: no disjuncts left in %s" (show flattened.dsjDisjuncts)
        -- When there is only one disjunct and the disjunct is not default, the disjunction is converted to the disjunct.
        | length final.dsjDisjuncts == 1 && null (dsjDefIndexes final) -> return $ head final.dsjDisjuncts
        | otherwise -> return $ mkDisjVal final

{- | Flatten the disjunction.

Because disjunction operation is associative, we can flatten the disjuncts. The nested disjunctions were like
parenthesized disjunctions. For example, (a | *b) | c | (d | e) = a | *b | c | d | e.

Notice before this step, there is no marked terms in the disjunction. For example, *(a | *b) has been reduced to (a |
*b).

This handles the case where a marked term is a reference. For example the f of the *f | v1 would be <f, f> if we use the
value-default pair. When the value of the f changes to a disjunction like *1 | 2, the flattened disjuncts would be 1 and
2 with the default index of di, where di is the index of the disjunct f. When the value of f changes to 1 | 2, the
flattened disjuncts would be 1 and 2 with the default indexes of di and di + 1.

It also follows the rules of disjunction operation:
D0: ⟨v1⟩ | ⟨v2⟩         => ⟨v1|v2⟩
D1: ⟨v1, d1⟩ | ⟨v2⟩     => ⟨v1|v2, d1⟩
D2: ⟨v1, d1⟩ | ⟨v2, d2⟩ => ⟨v1|v2, d1|d2⟩

TODO: more efficiency
-}
flattenDisjunction :: (Val -> Bool) -> Disj -> RM Disj
flattenDisjunction discardDisjunct (Disj{dsjDefIndexes = idxes, dsjDisjuncts = disjuncts}) = do
  reps <- mapM treeToRepString disjuncts
  debugInstantOpRM
    "flattenDisjunction"
    (const $ return $ printf "before disjuncts: %s, defIdxes: %s" (show reps) (show idxes))
    emptyValAddr

  -- Use foldl because the new default indexes are based on the length of the accumulated disjuncts.
  (newIndexes, newDisjs) <- foldM flatten ([], []) (zip [0 ..] disjuncts)
  return $ emptyDisj{dsjDefIndexes = newIndexes, dsjDisjuncts = newDisjs}
 where
  origDefIdxesSet = Set.fromList idxes
  -- Suppose we are processing the ith disjunct, and we have accumulated the disjuncts xs.
  -- If the ith disjunct is not a disjunction, then we can just add it to the disjuncts. We also need to add the index
  -- to the default indexes if it belongs to the default disjunction.
  flatten (accIs, accDs) (origIdx, t) = do
    debugInstantOpRM
      "flattenDisjunction"
      (const $ return $ printf "At %s, val: %s" (show origIdx) (show t))
      emptyValAddr
    case rtrDisj t of
      Just sub -> do
        Disj{dsjDefIndexes = subDefIndexes, dsjDisjuncts = subDisjs} <- flattenDisjunction discardDisjunct sub
        let
          -- Add offset to the indexes of the new disjuncts. The offset is the length of the accumulated disjuncts.
          newDefIndexes =
            -- If no sub defaults found for the disjunct but the disjunct is a default disjunct, that means the
            -- disjunct has been flattened to multiple disjuncts.
            if null subDefIndexes && origIdx `Set.member` origDefIdxesSet
              then map (+ length accDs) [0 .. length subDisjs - 1]
              else map (+ length accDs) subDefIndexes
        return (accIs ++ newDefIndexes, accDs ++ subDisjs)
      _ ->
        return
          ( if origIdx `Set.member` origDefIdxesSet
              -- The index of the new disjunct is the length of the accumulated disjuncts.
              then accIs ++ [length accDs]
              else accIs
          , accDs ++ [t]
          )

{- | Remove unwanted or rewrite the disjuncts.

All the disjuncts have been reduced before this step.

Unwanted disjuncts include:

* duplicate default disjuncts
* duplicate disjuncts
* bottom disjuncts

Rewrite includes:

* IsRefCycle
* Struct with embedded value

TODO: consider make t an instance of Ord and use Set to remove duplicates.
-}
modifyDisjuncts :: (Val -> Bool) -> Disj -> VCur -> RM Disj
modifyDisjuncts discardDisjunct idisj@(Disj{dsjDefIndexes = dfIdxes, dsjDisjuncts = disjuncts}) vc = do
  traceSpanArgsAdaptRM
    "modifyDisjuncts"
    ( const $ do
        disjStr <- tshow (mkDisjVal idisj)
        return $ show disjStr
    )
    emptySpanValue
    vc
    $ do
      (newIndexes, newDisjs) <- foldM go ([], []) (zip [0 ..] disjuncts)
      return $ emptyDisj{dsjDefIndexes = newIndexes, dsjDisjuncts = newDisjs}
 where
  defValues = map (disjuncts !!) dfIdxes
  origDefIdxesSet = Set.fromList dfIdxes

  go (accIs, accDisjs) (idx, v) = do
    let partialCancelled conjs = do
          rfbAddr <- rfbAddrToAddr <$> addrIsRfbAddr (vcAddr vc)
          return $
            filter
              ( \x -> case x of
                  FixSelect rcAddr -> rcAddr /= rfbAddr
                  _ -> True
              )
              conjs
    case v of
      -- Try if the RCs are cancellable.
      IsFix f
        | Just conjs <- partialCancelled f.conjs
        , -- If all conjuncts are cancelled, then we just use the inner value.
          null conjs ->
            -- If the inner value is NoVal, we just discard it.
            if f.val == VNNoVal
              then return (accIs, accDisjs)
              else return $ updateDisjuncts (accIs, accDisjs) (idx, mkNewVal f.val)
      IsEmbedVal ev -> return $ updateDisjuncts (accIs, accDisjs) (idx, ev)
      _ -> return $ updateDisjuncts (accIs, accDisjs) (idx, v)

  updateDisjuncts (accIs, accXs) (idx, x) =
    let
      notAddedDisj = not (x `elem` accXs)
      -- If the disjunct is equal to the default value. Note that it does not mean the disjunct is the original default
      -- value.
      isValEqDef = x `elem` defValues
      -- The disjunct is kept if all of the following conditions are met:
      -- 1. it is not a bottom disjunct.
      -- 2. it is not added before
      -- 3. it is not a default value OR it is one of the default disjuncts and its index is in the original default
      -- indexes.
      -- The second condition makes sure the relative order of the default disjuncts is kept.
      -- For example, *b | c | a | b | *a should be reduced to <b | c | a, 0|2>.
      keepDisjunct =
        not (discardDisjunct x)
          && notAddedDisj
          && (not isValEqDef || idx `Set.member` origDefIdxesSet)
      -- The disjunct is default if it is one of the default disjuncts and it is not seen before.
      isDefIndex = keepDisjunct && isValEqDef
     in
      -- Add the current disjunct index to the default indexes if condition is met.
      ( if isDefIndex then accIs ++ [length accXs] else accIs
      , if keepDisjunct then accXs ++ [x] else accXs
      )

{- | Construct a list of disjuncts from the disjunction terms.

Some existing rules for marked disjunctions:
M0:  ⟨v⟩    => ⟨v⟩        don't introduce defaults for unmarked term
M1: *⟨v⟩    => ⟨v, v⟩     introduce identical default for marked term
M2: *⟨v, d⟩ => ⟨v, d⟩     keep existing defaults for marked term
M3:  ⟨v, d⟩ => ⟨v⟩        strip existing defaults from unmarked term
-}
procMarkedTerms :: [DisjTerm] -> RM [Val]
procMarkedTerms terms = do
  -- disjoin operation allows incompleteness.
  let hasMarked = any dstMarked terms
  return $
    foldr
      ( \term accDisjuncts ->
          let val = dstValue term
           in if
                -- Apply Rule M1 and M2
                | hasMarked && dstMarked term ->
                    setVN
                      ( VNDisj $
                          maybe
                            -- Rule M1
                            (emptyDisj{dsjDefIndexes = [0], dsjDisjuncts = [val]})
                            ( \d ->
                                if null (dsjDefIndexes d)
                                  -- Rule M1
                                  then d{dsjDefIndexes = [0 .. length (dsjDisjuncts d)]}
                                  -- Rule M2
                                  else d
                            )
                            (rtrDisj val)
                      )
                      val
                      : accDisjuncts
                -- Apply Rule M0 and M3
                | hasMarked ->
                    maybe
                      val
                      (\d -> setVN (VNDisj $ d{dsjDefIndexes = []}) val)
                      (rtrDisj val)
                      : accDisjuncts
                | otherwise -> val : accDisjuncts
      )
      []
      terms
