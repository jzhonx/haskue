{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Reduce.Comprehension where

import Control.Monad (foldM)
import Cursor
import Data.Aeson (KeyValue (..), ToJSON (..), object)
import Data.Foldable (toList)
import qualified Data.IntMap.Strict as IntMap
import Data.List (intercalate)
import qualified Data.Map.Strict as Map
import Data.Maybe (fromJust)
import qualified Data.Sequence as Seq
import qualified Data.Set as Set
import qualified Data.Text as T
import Feature
import {-# SOURCE #-} Reduce.Core (reduce, reducePureVN, reduceToNonMut)
import Reduce.Monad (
  RM,
  allocRMObjID,
  getTMCursor,
  getTMVal,
  inSubTM,
  preVisitVal,
  preVisitValSimple,
  putTMCursor,
  putTMVal,
  setTMVN,
  throwFatal,
 )
import Reduce.TraceSpan (
  debugInstantTM,
  traceSpanArgsTM,
  traceSpanTM,
 )
import Reduce.Unification (unifyTCs)
import StringIndex (ShowWTIndexer (..), TextIndex, ToJSONWTIndexer (..))
import Text.Printf (printf)
import Util.Format (msprintf, packFmtA)
import Value
import Value.Export.Debug (treeToFullRepString, treeToRepString)

reduceCompreh :: Comprehension -> RM ()
reduceCompreh cph = traceSpanTM "reduceCompreh" $ do
  -- First set the valNode to VNNoVal to avoid last iteration result being used in the comprehension reduction.
  setTMVN VNNoVal
  r <-
    comprehend
      0
      cph.args
      (IterCtx{iterCnt = 0, bindings = cph.iterBindings, res = Right []})
  res <- case r.res of
    Left t -> return t
    Right revVCs ->
      let vcs = reverse revVCs
       in if cph.isListCompreh
            then do
              let vs = map focus vcs
              return $ mkListVal vs vs
            else case vcs of
              [] -> return $ mkStructVal emptyStruct
              [x] -> return x.focus
              _ -> do
                vc <- getTMCursor
                unifyTCs vcs vc

  debugInstantTM "reduceCompreh" (msprintf "comprehension result: %s" [packFmtA res])
  -- The result could be a struct, list or noval. But we should get rid of the mutable if there is any.
  setTMVN (valNode res)
  reducePureVN

data IterCtx = IterCtx
  { iterCnt :: Int
  -- ^ The count of the iterations.
  , bindings :: Map.Map TextIndex Val
  , res :: Either Val [VCur]
  -- ^ It contains a list of reversed resulted structs that are generated by each iteration.
  }
  deriving (Show)

instance ToJSON IterCtx where
  toJSON IterCtx{iterCnt} = object ["iterCnt" .= iterCnt]

instance ToJSONWTIndexer IterCtx where
  ttoJSON i = do
    bds <- ttoJSON i.bindings
    r <- case i.res of
      Left t -> do
        tRep <- oneLinerStringOfVal t
        return $ toJSON tRep
      Right ts -> do
        tReps <- mapM (oneLinerStringOfVal . focus) ts
        return $ toJSON tReps
    return $
      object
        [ "iterCnt" .= i.iterCnt
        , "bindings" .= bds
        , "res" .= r
        ]

tshowBindings :: Map.Map TextIndex Val -> RM T.Text
tshowBindings binds = do
  pairs <-
    mapM
      ( \(nameIdx, v) -> do
          name <- tshow nameIdx
          trep <- oneLinerStringOfVal v
          return $ printf "%s: %s" (T.unpack name) (T.unpack trep)
      )
      (Map.toList binds)
  return $ T.pack $ "{" ++ intercalate ", " pairs ++ "}"

{- | Iterate through the comprehension clauses.

The iteration is done in a depth-first manner. If all clauses are processed, it creates a new struct with the
bindings and adds the struct to the result list.
-}
comprehend :: Int -> Seq.Seq ComprehArg -> IterCtx -> RM IterCtx
comprehend i args iterCtx
  -- The case for the template struct.
  | let iterValIndex = length args - 1
  , i >= iterValIndex = traceSpanTM
      (printf "comprehend_last_iter_cl itercnt:%s, arg: %d" (show iterCtx.iterCnt) i)
      $ case iterCtx.res of
        Left err -> do
          rep <- treeToRepString err
          throwFatal $ printf "should not reach the leaf node if the result is already an error: %s" rep
        Right vs -> do
          -- Fork the template struct so that references in the struct can be resolved.
          tmplVal <- inSubTM (mkMutArgFeature (i - 1) False) getTMVal
          r <-
            inSubTM
              (mkMutArgFeature i False)
              ( do
                  putTMVal tmplVal
                  v <- forkStruct
                  r <- attachBindings iterCtx.bindings v
                  debugInstantTM
                    "comprehend_forked_iter_cl"
                    ( do
                        rep <- treeToFullRepString r
                        return $ T.pack $ printf "iteration %s struct: %s" (show iterCtx.iterCnt) rep
                    )
                  -- Make the forked struct of this iteration immutable because it would simplify later unification of
                  -- iteration results, mostly because of removal of the embedded value.
                  putTMVal r
                  reduceToNonMut >> setValImmutable <$> getTMVal
              )

          debugInstantTM
            "comprehend_last_iter_cl"
            (msprintf "iteration %s result struct: %s" [packFmtA (show iterCtx.iterCnt), packFmtA r])
          vc <- getTMCursor
          return $ iterCtx{res = Right (setVCFocus r vc : vs), iterCnt = iterCtx.iterCnt + 1}
  | otherwise = reduceClause i args iterCtx

-- | Fork the struct template for the comprehension iteration.
forkStruct :: RM VCur
forkStruct = do
  vc <- getTMCursor >>= mkUnique
  let t = focus vc
  case t of
    IsStruct _ | IsValImmutable <- t -> return vc
    -- The template struct can have embedded values.
    _
      | IsValMutable mut <- t
      , let args = getSOpArgs mut
      , (_, a) Seq.:<| _ <- args
      , IsStruct _ <- a -> do
          let res =
                foldM
                  ( \acc i -> do
                      argVC <- goDownVCSeg (mkMutArgFeature i True) acc
                      propUpVCMaybe argVC
                  )
                  vc
                  [1 .. length args - 1]
          case res of
            Just newVC -> return newVC
            Nothing -> throwFatal "failed to fork struct template in comprehension"
    _ -> throwFatal "attachBindings can only be used with a struct template"

mkUnique :: VCur -> RM VCur
mkUnique =
  preVisitValSimple
    (subNodes True)
    ( \vc -> case focus vc of
        IsStruct struct -> do
          newStruct <- mkUniqueStruct struct
          return $ setVCFocusVN (VNStruct newStruct) vc
        _ -> return vc
    )

mkUniqueStruct :: Struct -> RM Struct
mkUniqueStruct struct = do
  sid <- allocRMObjID
  newDynPairs <-
    mapM
      ( \df -> do
          oid <- allocRMObjID
          return (oid, df{dsfID = oid}, df.dsfID)
      )
      (IntMap.elems struct.stcDynFields)
  let newDyns = IntMap.fromList $ map (\(newID, df, _) -> (newID, df)) newDynPairs

  newCnstrPairs <-
    mapM
      ( \cnstr -> do
          cid <- allocRMObjID
          return (cid, cnstr{scsID = cid})
      )
      (IntMap.elems struct.stcCnstrs)
  let newCnstrs = IntMap.fromList newCnstrPairs
      dynIDMap = IntMap.fromList $ map (\(newID, _, oldID) -> (oldID, newID)) newDynPairs
      newOrdLabels =
        map
          ( \case
              StructStaticFieldLabel name -> StructStaticFieldLabel name
              StructDynFieldOID oldID -> StructDynFieldOID (fromJust $ IntMap.lookup oldID dynIDMap)
          )
          struct.stcOrdLabels
  return
    struct
      { stcID = sid
      , stcDynFields = newDyns
      , stcCnstrs = newCnstrs
      , stcOrdLabels = newOrdLabels
      }

-- | Reduce the ith clause of the comprehension in the depth-first manner.
reduceClause :: Int -> Seq.Seq ComprehArg -> IterCtx -> RM IterCtx
reduceClause _ _ iterCtx@IterCtx{res = Left _} = return iterCtx
reduceClause i args iterCtx = case args `Seq.index` i of
  ComprehArgIterVal _ -> throwFatal "ComprehArgIterVal should not appear in comprehension clauses"
  ComprehArgTmpl _ -> comprehend (i + 1) args iterCtx
  ComprehArgLet letName _ -> do
    t <- reduceClauseWithBindings i iterCtx.bindings
    case t of
      IsNoVal -> return iterCtx
      IsBottom _ -> return $ iterCtx{res = Left t}
      _ -> comprehend (i + 1) args (iterCtx{bindings = Map.insert letName t iterCtx.bindings})
  ComprehArgIf _ -> do
    t <- reduceClauseWithBindings i iterCtx.bindings
    case t of
      IsNoVal -> return iterCtx
      IsBottom _ -> return $ iterCtx{res = Left t}
      _ -> case rtrAtom t of
        Just (Bool True) -> comprehend (i + 1) args iterCtx
        -- Do not go to next clause if the condition is false.
        Just (Bool False) -> return iterCtx
        _ -> return $ iterCtx{res = Left $ mkBottomVal $ printf "%s is not a boolean" (showValSymbol t)}
  ComprehArgFor k vM _ -> do
    t <- reduceClauseWithBindings i iterCtx.bindings
    if
      | IsNoVal <- t -> return iterCtx
      | IsBottom _ <- t -> return $ iterCtx{res = Left t}
      -- TODO: only iterate optional fields
      | IsStruct struct <- t ->
          foldM
            ( \acc (labelIdx, field) -> do
                label <- tshow labelIdx
                comprehend
                  (i + 1)
                  args
                  ( acc
                      { bindings =
                          Map.union
                            ( Map.fromList $
                                maybe
                                  [(k, ssfValue field)]
                                  (\v -> [(k, mkAtomVal (String label)), (v, ssfValue field)])
                                  vM
                            )
                            acc.bindings
                      }
                  )
            )
            iterCtx
            (Map.toList $ stcFields struct)
      | Just (List{store}) <- rtrList t ->
          foldM
            ( \acc (idx, element) ->
                comprehend
                  (i + 1)
                  args
                  ( acc
                      { bindings =
                          Map.union
                            ( Map.fromList $
                                maybe
                                  [(k, element)]
                                  (\v -> [(k, mkAtomVal (Int idx)), (v, element)])
                                  vM
                            )
                            acc.bindings
                      }
                  )
            )
            iterCtx
            (zip [0 ..] (toList store))
      | otherwise ->
          return $
            iterCtx
              { res = Left $ mkBottomVal $ printf "%s is not iterable" (showValSymbol t)
              }

-- | Embed a value to a new block and return a new tree cursor that points to the embedded value.
reduceClauseWithBindings :: Int -> Map.Map TextIndex Val -> RM Val
reduceClauseWithBindings i bindings = traceSpanArgsTM
  (printf "reduceClauseWithBindings clause:%d" i)
  ( \() -> T.unpack <$> tshowBindings bindings
  )
  $ do
    vc <- getTMCursor
    case vc of
      VCFocus (IsValMutable mut@(Op (Compreh cph))) -> do
        let newTC = modifyVCFocus (\t -> t{op = Just $ setOpInSOp (Compreh cph{iterBindings = bindings}) mut}) vc
        putTMCursor newTC
        inSubTM (mkMutArgFeature i False) (reduce >> getTMVal)
      _ -> throwFatal "reduceClauseWithBindings can only be used with a mutable comprehension"

-- | Make bindings immutable and insert into the template struct.
attachBindings :: Map.Map TextIndex Val -> VCur -> RM Val
attachBindings rawBindings vc = do
  let bindings = Map.map setValImmutable rawBindings
  (uvc, newBindings) <- createBindings bindings vc
  let t = focus uvc
  case t of
    IsStruct struct | IsValImmutable <- t -> return $ setVN (VNStruct $ struct{stcBindings = newBindings}) t
    -- The template struct can have embedded values.
    _
      | IsValMutable mut <- t
      , let args = getSOpArgs mut
      , (f, a) Seq.:<| _ <- args
      , IsStruct tmplStruct <- a ->
          let res = do
                subVC <- goDownVCSeg f uvc
                let modified = modifyVCFocus (setVN (VNStruct $ tmplStruct{stcBindings = newBindings})) subVC
                propUpVCMaybe modified
           in case res of
                Just newVC -> return $ focus newVC
                Nothing -> throwFatal "failed to attach bindings to struct template in comprehension"
    _ -> throwFatal "attachBindings can only be used with a struct template"

createBindings :: Map.Map TextIndex Val -> VCur -> RM (VCur, Map.Map TextIndex Binding)
createBindings bindings vc = do
  mapping <- Map.fromList <$> createMapping
  (uVC, (visited, _)) <- preVisitVal (subNodes True) go (vc, (Set.empty, mapping))
  let refinedBindings =
        foldr
          ( \ti acc ->
              let newTI = fromJust $ Map.lookup ti mapping
               in Map.insert newTI (Binding (fromJust $ Map.lookup ti bindings) True) acc
          )
          Map.empty
          (Set.toList visited)
  return (uVC, refinedBindings)
 where
  createMapping =
    mapM
      ( \ti -> do
          suffix <- allocRMObjID
          newTI <- modifyTISuffix suffix ti
          return (ti, newTI)
      )
      (Map.keys bindings)

  go (cur, (visited, mapping)) = case cur.focus of
    IsRef op (Reference identTI xs) -> case Map.lookup identTI mapping of
      Just newTI -> do
        let newOp = modifyRefInSOp (const $ Reference newTI xs) op
            newCur = modifyVCFocus (setTOp newOp) cur
        return (newCur, (Set.insert identTI visited, mapping))
      Nothing -> return (cur, (visited, mapping))
    _ -> return (cur, (visited, mapping))

resolveInterpolation :: Interpolation -> [Val] -> RM (Maybe Val)
resolveInterpolation l args = do
  r <-
    foldM
      ( \accRes seg -> case seg of
          IplSegExpr j -> do
            let r = args !! j
            if
              | Just s <- rtrString r -> return $ (`T.append` s) <$> accRes
              | Just i <- rtrInt r -> return $ (`T.append` (T.pack $ show i)) <$> accRes
              | Just b <- rtrBool r -> return $ (`T.append` (T.pack $ show b)) <$> accRes
              | Just f <- rtrFloat r -> return $ (`T.append` (T.pack $ show f)) <$> accRes
              | Just _ <- rtrStruct r ->
                  return $
                    Left $
                      mkBottomVal $
                        printf "can not use struct in interpolation: %s" (showValSymbol r)
              | Just _ <- rtrList r ->
                  return $
                    Left $
                      mkBottomVal $
                        printf "can not use list in interpolation: %s" (showValSymbol r)
              | otherwise -> throwFatal $ printf "unsupported interpolation expression: %s" (showValSymbol r)
          IplSegStr s -> return $ (`T.append` s) <$> accRes
      )
      (Right T.empty)
      (itpSegs l)
  case r of
    Left err -> return $ Just err
    Right res -> return $ Just $ mkAtomVal (String res)
