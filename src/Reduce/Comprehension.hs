{-# LANGUAGE ConstraintKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}

module Reduce.Comprehension where

import Control.Monad (foldM, forM_)
import Cursor
import Data.Aeson (KeyValue (..), ToJSON (..), object)
import Data.Foldable (toList)
import qualified Data.IntMap.Strict as IntMap
import Data.List (intercalate)
import qualified Data.Map.Strict as Map
import Data.Maybe (fromJust)
import qualified Data.Sequence as Seq
import qualified Data.Text as T
import Feature
import {-# SOURCE #-} Reduce.Core (reduce, reducePureVN, reduceToNonMut)
import Reduce.Monad (
  RM,
  allocRMObjID,
  getTMCursor,
  getTMVal,
  inSubTM,
  inTempTM,
  modifyTMVN,
  modifyTMVal,
  putTMCursor,
  throwFatal,
 )
import Reduce.TraceSpan (
  debugInstantTM,
  traceSpanTM,
 )
import StringIndex (ShowWTIndexer (..), TextIndex, ToJSONWTIndexer (..))
import Text.Printf (printf)
import Util.Format (msprintf, packFmtA)
import Value
import Value.Export.Debug (treeToRepString)

reduceCompreh :: Comprehension -> RM ()
reduceCompreh cph = traceSpanTM "reduceCompreh" $ do
  r <- comprehend 0 cph.args (IterCtx 0 Map.empty (Right []))
  res <- case r.res of
    Left t -> return t
    Right vs ->
      if cph.isListCompreh
        then return $ mkListVal vs vs
        else case vs of
          [] -> return $ mkStructVal emptyStruct
          [x] -> return x
          _ -> do
            let mutT = mkMutableVal $ mkUnifyOp vs
            inTempTM "reduceCompreh" mutT $ reduce >> getTMVal

  debugInstantTM "reduceCompreh" (msprintf "comprehension result: %s" [packFmtA res])
  -- The result could be a struct, list or noval. But we should get rid of the mutable if there is any.
  modifyTMVN (valNode res)
  reducePureVN

data IterCtx = IterCtx
  { iterCnt :: Int
  -- ^ The count of the iterations.
  , bindings :: Map.Map TextIndex Val
  , res :: Either Val [Val]
  -- ^ It contains a list of resulted structs that are generated by each iteration.
  }
  deriving (Show)

instance ToJSON IterCtx where
  toJSON IterCtx{iterCnt} = object ["iterCnt" .= iterCnt]

instance ToJSONWTIndexer IterCtx where
  ttoJSON i = do
    bds <- ttoJSON i.bindings
    r <- case i.res of
      Left t -> do
        tRep <- oneLinerStringOfVal t
        return $ toJSON tRep
      Right ts -> do
        tReps <- mapM oneLinerStringOfVal ts
        return $ toJSON tReps
    return $
      object
        [ "iterCnt" .= i.iterCnt
        , "bindings" .= bds
        , "res" .= r
        ]

tshowBindings :: Map.Map TextIndex Binding -> RM T.Text
tshowBindings binds = do
  pairs <-
    mapM
      ( \(nameIdx, b) -> do
          name <- tshow nameIdx
          trep <- oneLinerStringOfVal b.value
          return $ printf "%s: %s" (T.unpack name) (T.unpack trep)
      )
      (Map.toList binds)
  return $ T.pack $ "{" ++ intercalate ", " pairs ++ "}"

{- | Iterate through the comprehension clauses.

The iteration is done in a depth-first manner. If all clauses are processed, it creates a new struct with the
bindings and adds the struct to the result list.
-}
comprehend :: Int -> Seq.Seq ComprehArg -> IterCtx -> RM IterCtx
comprehend i args iterCtx
  -- The case for the template struct.
  | i >= length args - 1 = traceSpanTM
      (printf "comprehend_last_iter_cl itercnt:%s, arg: %d" (show iterCtx.iterCnt) i)
      $ case iterCtx.res of
        Left err -> do
          rep <- treeToRepString err
          throwFatal $ printf "should not reach the leaf node if the result is already an error: %s" rep
        Right vs -> do
          -- Fork the template struct so that references in the struct can be resolved.
          r <-
            inSubTM
              (mkMutArgFeature i False)
              ( do
                  attachBindings iterCtx.bindings
                  forkStruct
              )
          -- Make the forked struct of this iteration immutable because it would simplify later unification of
          -- iteration results, mostly because of removal of the embedded value.
          r2 <- inTempTM "iter_struct" r $ reduceToNonMut >> setValImmutable <$> getTMVal
          return $ iterCtx{res = Right (vs ++ [r2]), iterCnt = iterCtx.iterCnt + 1}
  | otherwise = reduceClause i args iterCtx

-- | Fork the struct template for the comprehension iteration.
forkStruct :: RM Val
forkStruct = do
  t <- getTMVal
  case t of
    IsStruct struct
      | IsValImmutable <- t -> do
          -- The original let bindings in the struct should take the precedence over the iteration bindings.
          newStruct <- mkUnique struct
          return $ setVN (VNStruct newStruct) t
    -- The template struct can have embedded values.
    _
      | IsValMutable mut <- t
      , let args = getSOpArgs mut
      , (_, a) Seq.:<| _ <- args
      , IsStruct tmplStruct <- a -> do
          newStruct <- mkUnique tmplStruct
          inSubTM (mkMutArgFeature 0 True) $ modifyTMVN $ VNStruct newStruct
          forM_ [1 .. length args - 1] $ \i ->
            inSubTM (mkMutArgFeature i True) $ modifyTMVal $ \x -> x{embType = ETEmbedded newStruct.stcID}
          getTMVal
    _ -> throwFatal "attachBindings can only be used with a struct template"
 where
  mkUnique struct = do
    sid <- allocRMObjID
    newDynPairs <-
      mapM
        ( \df -> do
            oid <- allocRMObjID
            return (oid, df{dsfID = oid}, df.dsfID)
        )
        (IntMap.elems struct.stcDynFields)
    let
      dynIDMap = IntMap.fromList $ map (\(newID, _, oldID) -> (oldID, newID)) newDynPairs
      newDyns = IntMap.fromList $ map (\(newID, df, _) -> (newID, df)) newDynPairs
    newCnstrPairs <-
      mapM
        ( \cnstr -> do
            cid <- allocRMObjID
            return (cid, cnstr{scsID = cid})
        )
        (IntMap.elems struct.stcCnstrs)
    let newCnstrs = IntMap.fromList newCnstrPairs
        newOrdLabels =
          map
            ( \case
                StructStaticFieldLabel name -> StructStaticFieldLabel name
                StructDynFieldOID oldID -> StructDynFieldOID (fromJust $ IntMap.lookup oldID dynIDMap)
            )
            struct.stcOrdLabels
    return
      struct
        { stcID = sid
        , stcDynFields = newDyns
        , stcCnstrs = newCnstrs
        , stcOrdLabels = newOrdLabels
        }

-- | Reduce the ith clause of the comprehension in the depth-first manner.
reduceClause :: Int -> Seq.Seq ComprehArg -> IterCtx -> RM IterCtx
reduceClause _ _ iterCtx@IterCtx{res = Left _} = return iterCtx
reduceClause i args iterCtx = case args `Seq.index` i of
  ComprehArgStructTmpl _ -> throwFatal "ComprehArgStructTmpl should not appear in comprehension clauses"
  ComprehArgLet letName _ -> do
    t <- reduceClauseWithBindings i iterCtx.bindings
    case t of
      IsNoVal -> return iterCtx
      IsBottom _ -> return $ iterCtx{res = Left t}
      _ -> comprehend (i + 1) args (iterCtx{bindings = Map.insert letName t iterCtx.bindings})
  ComprehArgIf _ -> do
    t <- reduceClauseWithBindings i iterCtx.bindings
    case t of
      IsNoVal -> return iterCtx
      IsBottom _ -> return $ iterCtx{res = Left t}
      _ -> case rtrAtom t of
        Just (Bool True) -> comprehend (i + 1) args iterCtx
        -- Do not go to next clause if the condition is false.
        Just (Bool False) -> return iterCtx
        _ -> return $ iterCtx{res = Left $ mkBottomVal $ printf "%s is not a boolean" (showValSymbol t)}
  ComprehArgFor k vM _ -> do
    t <- reduceClauseWithBindings i iterCtx.bindings
    if
      | IsNoVal <- t -> return iterCtx
      | IsBottom _ <- t -> return $ iterCtx{res = Left t}
      -- TODO: only iterate optional fields
      | IsStruct struct <- t ->
          foldM
            ( \acc (labelIdx, field) -> do
                label <- tshow labelIdx
                comprehend
                  (i + 1)
                  args
                  ( acc
                      { bindings =
                          Map.union
                            ( Map.fromList $
                                maybe
                                  [(k, ssfValue field)]
                                  (\v -> [(k, mkAtomVal (String label)), (v, ssfValue field)])
                                  vM
                            )
                            acc.bindings
                      }
                  )
            )
            iterCtx
            (Map.toList $ stcFields struct)
      | Just (List{store}) <- rtrList t ->
          foldM
            ( \acc (idx, element) ->
                comprehend
                  (i + 1)
                  args
                  ( acc
                      { bindings =
                          Map.union
                            ( Map.fromList $
                                maybe
                                  [(k, element)]
                                  (\v -> [(k, mkAtomVal (Int idx)), (v, element)])
                                  vM
                            )
                            acc.bindings
                      }
                  )
            )
            iterCtx
            (zip [0 ..] (toList store))
      | otherwise ->
          return $
            iterCtx
              { res = Left $ mkBottomVal $ printf "%s is not iterable" (showValSymbol t)
              }

-- | Embed a value to a new block and return a new tree cursor that points to the embedded value.
reduceClauseWithBindings :: Int -> Map.Map TextIndex Val -> RM Val
reduceClauseWithBindings i bindings = do
  vc <- getTMCursor
  case vc of
    VCFocus (IsValMutable mut@(Op (Compreh cph))) -> do
      let newTC = modifyVCFocus (\t -> t{op = Just $ setOpInSOp (Compreh cph{iterBindings = bindings}) mut}) vc
      putTMCursor newTC
      inSubTM (mkMutArgFeature i False) (reduce >> getTMVal)
    _ -> throwFatal "reduceClauseWithBindings can only be used with a mutable comprehension"

-- | Make bindings immutable and insert into the template struct.
attachBindings :: Map.Map TextIndex Val -> RM ()
attachBindings rawBindings = do
  let bindings = Map.map setValImmutable rawBindings
  t <- getTMVal
  case t of
    IsStruct struct
      | IsValImmutable <- t -> do
          -- The original let bindings in the struct should take the precedence over the iteration bindings.
          let
            cleanBindings = Map.filter (not . isIterVar) struct.stcBindings
            newBindings =
              Map.union
                cleanBindings
                (Map.map (\x -> Binding x True) bindings)
          bStr <- tshowBindings newBindings
          debugInstantTM "attachBindings" (msprintf "imm struct's new bindings: %s" [packFmtA bStr])
          modifyTMVN $ VNStruct $ struct{stcBindings = newBindings}
    -- The template struct can have embedded values.
    _
      | IsValMutable mut <- t
      , let args = getSOpArgs mut
      , (f, a) Seq.:<| _ <- args
      , IsStruct tmplStruct <- a -> do
          -- The original let bindings in the struct should take the precedence over the iteration bindings.
          let
            cleanBindings = Map.filter (not . isIterVar) tmplStruct.stcBindings
            newBindings =
              Map.union
                cleanBindings
                (Map.map (\x -> Binding x True) bindings)
          bStr <- tshowBindings newBindings
          debugInstantTM "attachBindings" (msprintf "new bindings: %s" [packFmtA bStr])
          inSubTM f $ modifyTMVN $ VNStruct $ tmplStruct{stcBindings = newBindings}
    _ -> throwFatal "attachBindings can only be used with a struct template"

resolveInterpolation :: Interpolation -> [Val] -> RM (Maybe Val)
resolveInterpolation l args = do
  r <-
    foldM
      ( \accRes seg -> case seg of
          IplSegExpr j -> do
            let r = args !! j
            if
              | Just s <- rtrString r -> return $ (`T.append` s) <$> accRes
              | Just i <- rtrInt r -> return $ (`T.append` (T.pack $ show i)) <$> accRes
              | Just b <- rtrBool r -> return $ (`T.append` (T.pack $ show b)) <$> accRes
              | Just f <- rtrFloat r -> return $ (`T.append` (T.pack $ show f)) <$> accRes
              | Just _ <- rtrStruct r ->
                  return $
                    Left $
                      mkBottomVal $
                        printf "can not use struct in interpolation: %s" (showValSymbol r)
              | Just _ <- rtrList r ->
                  return $
                    Left $
                      mkBottomVal $
                        printf "can not use list in interpolation: %s" (showValSymbol r)
              | otherwise -> throwFatal $ printf "unsupported interpolation expression: %s" (showValSymbol r)
          IplSegStr s -> return $ (`T.append` s) <$> accRes
      )
      (Right T.empty)
      (itpSegs l)
  case r of
    Left err -> return $ Just err
    Right res -> return $ Just $ mkAtomVal (String res)
